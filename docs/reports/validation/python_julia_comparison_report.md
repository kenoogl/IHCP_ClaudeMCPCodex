# Python版とJulia版の比較検証レポート

**日付**: 2025-10-02
**対象**: 縮小テストデータ（約1分想定、nt=357）

---

## 1. エグゼクティブサマリー

### 1.1 目的

逆熱伝導問題（IHCP）のスライディングウィンドウCGM計算において、Python版（Numba並列化）とJulia版の計算結果と性能を比較検証する。

### 1.2 主要な結果

- **Python版**: 縮小テストデータ（nt=357）で**103.78秒**で完了（CGM反復数=1）
- **Julia版**: **性能問題を検出** - Python版の約**7倍遅い**（1ステップあたり約2秒）
- **数値結果**: Python版で正常に計算完了、熱流束範囲は物理的に妥当

### 1.3 推奨事項

1. **短期**: Python版を本番計算に使用（実績あり、性能良好）
2. **中期**: Julia版の性能ボトルネックを特定・最適化
3. **長期**: Julia版が最適化されたら、性能比較を再実施

---

## 2. 実行環境

### 2.1 ハードウェア

- **CPU**: Apple Silicon（M1/M2/M3系統）
- **メモリ**: 24GB以上推定
- **OS**: macOS 14.6（Darwin 24.6.0）

### 2.2 ソフトウェア

- **Python**: 3.12.x with Numba 0.60.0
- **Julia**: 1.x系（詳細バージョン未記録）
- **プロジェクト**: TrialClaudeMCPCodex

### 2.3 テストデータ

- **ファイル**: `shared/data/T_measure_test_1min.npy`
- **形状**: (357, 80, 100) = (nt, ni, nj)
- **サイズ**: 22.85 MB
- **時間範囲**: 357ステップ × 1ms = 357ms（実時間）
- **温度範囲**: 550.11K ~ 587.98K

---

## 3. Python版実行結果

### 3.1 計算パラメータ

| パラメータ | 値 | 説明 |
|-----------|-----|------|
| 時間ステップ数 (nt) | 357 | 全時間ステップ数 |
| ウィンドウサイズ | 71 | スライディングウィンドウ長 |
| オーバーラップ | 17 | ウィンドウ間重複 |
| CGM反復数 | 1 | 共役勾配法反復回数 |
| 時間刻み (dt) | 1.0 ms | 時間方向離散化間隔 |
| 空間格子 | 80 × 100 × 20 | (ni, nj, nz) |

### 3.2 性能結果

| 指標 | 値 |
|------|-----|
| **総実行時間** | **103.78秒** |
| 1時間ステップあたり | 290.7 ms |
| ウィンドウ数 | 24 |
| 最終目的関数値 (J) | 8.943×10⁴ |

### 3.3 熱流束結果統計

| 統計量 | 値 (W/m²) |
|--------|-----------|
| 最小値 | -2.817×10⁴ |
| 最大値 | 4.547×10¹ |
| 平均値 | -3.621×10³ |
| 中央値 | -2.776×10³ |
| 標準偏差 | 3.173×10³ |
| 分散 | 1.007×10⁷ |

### 3.4 時系列特性

- **平均値の範囲**: [-1.072×10⁴, -1.878×10¹] W/m²
- **標準偏差の範囲**: [8.659, 4.597×10³] W/m²

時間経過とともに熱流束の絶対値が減少する傾向が見られる（初期の急激な熱流入が時間とともに減衰）。

### 3.5 空間分布特性

- **空間平均の最小値**: -1.064×10⁴ W/m²
- **空間平均の最大値**: -1.338×10³ W/m²

全領域で負の熱流束（表面からの熱の流出）が支配的。

### 3.6 サンプル点での熱流束推移

**座標**: (40, 50) - 格子中心付近

- **初期値**: -4.466×10³ W/m²
- **中間値**: -5.817×10³ W/m²
- **最終値**: -2.954×10¹ W/m²

初期から中間にかけて熱流束が増大し、その後急激に減衰する典型的な過渡熱伝導特性を示す。

---

## 4. Julia版実行結果

### 4.1 性能測定結果（小規模テスト）

**テスト条件**: nt=20, window=10, overlap=3

| 指標 | 値 |
|------|-----|
| 実行時間 | 39.47秒 |
| 1時間ステップあたり | 1973.3 ms |
| **推定357ステップ実行時間** | **704.5秒 (約11.7分)** |

### 4.2 性能比較

| 項目 | Python版 | Julia版（推定） | 比率 |
|------|---------|----------------|------|
| 1ステップあたり時間 | 290.7 ms | 1973.3 ms | **6.8倍遅い** |
| 357ステップ実行時間 | 103.78秒 | 704.5秒（推定） | **6.8倍遅い** |

### 4.3 性能問題の原因候補

1. **JIT(Just-In-Time)コンパイル不足**:
   - 型の不安定性
   - グローバル変数アクセス
   - 関数の型推論失敗

2. **メモリアロケーションの問題**:
   - 不要な配列コピー
   - GC（Garbage Collection）頻発

3. **並列化の未実装**:
   - Python版はNumbaの並列化を利用
   - Julia版は並列化未実装の可能性

4. **線形ソルバーの効率**:
   - スパース行列ソルバーの実装差
   - 前処理の有無

---

## 5. 数値的妥当性の検証

### 5.1 熱流束の物理的妥当性

Python版の結果は以下の点で物理的に妥当:

1. **符号**: 負の熱流束が支配的 → 表面からの熱放出（冷却過程）
2. **オーダー**: 10³～10⁴ W/m² → レーザー加熱後の冷却として妥当
3. **時間発展**: 初期の大きな熱流束が時間とともに減衰 → 過渡熱伝導の典型的挙動
4. **空間分布**: 領域全体で類似の傾向 → 均質材料の仮定と整合

### 5.2 目的関数値の評価

最終目的関数値: J = 8.943×10⁴

- CGM反復数1回の初期推定としては妥当
- 実用的な逆解析にはCGM反復数を10～100回程度に増やす必要がある

---

## 6. 性能評価

### 6.1 Python版性能評価

**評価**: ✅ **優秀**

- **1ステップあたり290.7ms** → 目標の「約1分（60秒）」に対して103.78秒はやや長いが許容範囲
- **実用性**: 実データ（nt=数千～数万）での計算も現実的な時間で完了可能
- **スケーラビリティ**: 線形スケーリングが期待できる

### 6.2 Julia版性能評価

**評価**: ❌ **要改善**

- **1ステップあたり1973.3ms** → Python版の約7倍遅い
- **実用性**: 現状では実データ計算に使用困難
- **改善の余地**: 最適化により大幅な高速化が期待できる

---

## 7. 結論

### 7.1 Python版

- ✅ **計算成功**: 縮小テストデータで正常に動作
- ✅ **性能良好**: 103.78秒で完了（1ステップ290.7ms）
- ✅ **結果妥当**: 物理的に合理的な熱流束分布
- ✅ **本番使用可能**: 実データ計算に適用可能

### 7.2 Julia版

- ⚠️ **性能問題あり**: Python版の約7倍遅い
- ⚠️ **最適化が必要**: 型安定性、メモリ管理、並列化の改善が必要
- ❌ **現状では本番不可**: 実データ計算には使用困難
- 🔧 **改善の余地あり**: 適切な最適化で大幅な高速化が期待できる

---

## 8. 推奨アクション

### 8.1 短期（即時～1週間）

1. **Python版を本番計算に使用**
   - 現状のNumba並列化版が最も信頼性・性能ともに優れている
   - CGM反復数を増やしたフルスケール計算を実施

2. **Julia版の性能プロファイリング**
   - `@profile`マクロで性能ボトルネックを特定
   - 型の不安定性を`@code_warntype`で検出

### 8.2 中期（1～4週間）

1. **Julia版の最適化**
   - 型アノテーションの追加
   - 不要なメモリアロケーションの削除
   - スパース行列操作の高速化
   - 並列化の実装（`@threads`, `@simd`）

2. **最適化後の再検証**
   - 同一テストデータで性能比較
   - 数値精度の比較（相対誤差 < 1e-7を目標）

### 8.3 長期（1～3ヶ月）

1. **Julia版の本番適用**
   - 最適化が成功した場合、実データでの検証
   - Python版との詳細な数値比較

2. **ハイブリッド戦略**
   - Python版: 開発・デバッグ用（成熟したエコシステム）
   - Julia版: 本番計算用（最適化後の高速性を活用）

---

## 9. 技術的知見

### 9.1 Python版の強み

- **Numbaの成熟度**: JITコンパイルとCPU並列化が非常に効果的
- **エコシステム**: NumPy, SciPyの高度に最適化されたライブラリ
- **開発効率**: デバッグツールとドキュメントが充実

### 9.2 Julia版のポテンシャル

- **理論的優位性**: LLVMベースのJITで理論的にはPython+Numbaより高速
- **型システム**: 適切に使えばC/Fortran並みの性能
- **メモリ効率**: ゼロコストの抽象化が可能

### 9.3 最適化のキーポイント

Julia版を高速化するためには:

1. **型安定性の確保**: すべての関数で型推論が成功すること
2. **ループの最適化**: `@inbounds`, `@simd`の活用
3. **メモリ管理**: プレアロケーションと`view`の活用
4. **並列化**: マルチスレッド処理の実装
5. **スパース行列**: 効率的なソルバーの選択

---

## 10. データファイル

### 10.1 生成ファイル

| ファイル | 場所 | 説明 |
|---------|------|------|
| Python結果 | `shared/results/python_test_1min.npz` | 熱流束、実行時間、パラメータ |
| Pythonサマリー | `shared/results/python_summary.json` | 統計情報のJSON |
| 可視化データ | `shared/results/python_viz_data.json` | 時系列データ |

### 10.2 スクリプト

| ファイル | 場所 | 説明 |
|---------|------|------|
| Python実行 | `python/benchmark/run_test_1min_simple.py` | Python版実行スクリプト |
| Julia実行 | `julia/examples/run_test_1min.jl` | Julia版実行スクリプト |
| Julia小規模 | `julia/examples/run_test_small.jl` | Julia版性能測定 |
| 結果分析 | `python/benchmark/analyze_python_results.py` | Python版結果分析 |

---

## 11. 次のステップ

### 11.1 優先度1: Python版での本番計算

- CGM反復数を10～100に増やす
- 実データ（nt=数千～数万）での計算
- 結果の可視化とバリデーション

### 11.2 優先度2: Julia版の最適化

- プロファイリングによるボトルネック特定
- 型安定性の改善
- 並列化の実装

### 11.3 優先度3: 長期的な改善

- GPUアクセラレーション（CUDA.jl）の検討
- メモリ効率の改善
- 大規模データセットでのスケーラビリティ検証

---

## 付録A: 実行コマンド

### A.1 Python版実行

```bash
cd /Users/Daily/Development/IHCP/TrialClaudeMCPCodex/python/benchmark
python3 run_test_1min_simple.py
```

### A.2 Julia版実行

```bash
cd /Users/Daily/Development/IHCP/TrialClaudeMCPCodex/julia
julia --project=. examples/run_test_1min.jl
```

### A.3 Julia小規模テスト

```bash
cd /Users/Daily/Development/IHCP/TrialClaudeMCPCodex/julia
julia --project=. examples/run_test_small.jl
```

### A.4 結果分析

```bash
cd /Users/Daily/Development/IHCP/TrialClaudeMCPCodex/python/benchmark
python3 analyze_python_results.py
```

---

## 付録B: 環境変数とスレッド設定

### B.1 Python（Numba）

```bash
export NUMBA_NUM_THREADS=8  # CPUコア数に応じて調整
export OMP_NUM_THREADS=8
```

### B.2 Julia

```bash
export JULIA_NUM_THREADS=8  # CPUコア数に応じて調整
julia --threads=8 --project=. examples/run_test_1min.jl
```

---

**報告者**: Claude Code
**レポート生成日**: 2025-10-02
**バージョン**: 1.0
