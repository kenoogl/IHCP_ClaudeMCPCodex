# ガイドセルとマスク配列の詳細分析

**作成日**: 2025年10月3日
**目的**: Heat3dsのガイドセル方式とIHCPの境界条件処理の違いを明確化

## 1. Heat3dsのデータ構造とマスク配列

### 1.1 配列サイズとインデックス範囲

**配列サイズ**: `[ni+2, nj+2, nk+2]`

| 領域 | インデックス範囲 | 意味 |
|------|----------------|------|
| **計算内点** | `[2:ni+1, 2:nj+1, 2:nk+1]` | 実際の物理領域（ni×nj×nk個） |
| **ガイドセル** | `1`と`ni+2`（各次元） | 境界の外側の仮想セル |

**例**: ni=40の場合
- 配列サイズ: 42（40個の内点 + 2個のガイドセル）
- 内点: i=2:41
- ガイドセル: i=1（西側境界の外）、i=42（東側境界の外）

### 1.2 マスク配列の役割

**マスク値の意味**:
```julia
mask = ones(Float64, SZ[1], SZ[2], SZ[3])  # 初期化（全て1.0）
```

- **mask = 1.0**: 計算領域内の点（内点）
- **mask = 0.0**: 境界セル（境界条件が適用済み）

**境界条件適用後のマスク値**（boundary_conditions.jl より）:

| 境界条件タイプ | mask[境界] | λ[境界] | θ[境界] |
|-------------|----------|--------|--------|
| **等温（ISOTHERMAL）** | 0.0 | λ[内点]（同じ値） | 指定温度 |
| **熱流束（HEAT_FLUX）** | 0.0 | **0.0** | - |
| **熱伝達（CONVECTION）** | 0.0 | **0.0** | 周囲温度 |

### 1.3 λf関数による境界条件の統合処理

**λf関数の定義**（common.jl: 22行）:
```julia
λf(a, b, ma, mb) = 2.0*a*b / (a+b) * (2.0-div(ma+mb,2))
```

**分解**:
1. `2.0*a*b / (a+b)`: 調和平均（セル界面の熱伝導率）
2. `(2.0-div(ma+mb,2))`: マスク補正項

**マスク補正の効果**:

| ケース | ma | mb | div(ma+mb, 2) | 補正項 | 結果 |
|--------|----|----|--------------|--------|------|
| 両方内点 | 1 | 1 | 1 | 2.0-1=**1.0** | 調和平均そのまま |
| 一方境界 | 1 | 0 | 0 | 2.0-0=**2.0** | 調和平均×2.0 |
| 一方境界 | 0 | 1 | 0 | 2.0-0=**2.0** | 調和平均×2.0 |
| 両方境界 | 0 | 0 | 0 | 2.0-0=**2.0** | 調和平均×2.0 |

**熱流束境界の場合**（λ[境界]=0.0）:
```julia
λf(λ[境界], λ[内点], 0, 1) = 2.0*0*λ[内点]/(0+λ[内点]) * 2.0 = 0
```
→ **境界での熱伝導項が自動的にゼロになる**

### 1.4 CalcAX!関数での境界条件の適用

**heat3d_NonUniform.jl: 539-560行**:
```julia
@floop backend for k in z_st:z_ed, j in 2:SZ[2]-1, i in 2:SZ[1]-1
    λ0 = λ[i,j,k]
    m0 = m[i,j,k]  # 中心セルのマスク値

    # 6方向のマスク値（隣接セル）
    mw = 1.0-m[i-1,j  ,k  ]  # 西側の「境界フラグ」（1-mask）
    me = 1.0-m[i+1,j  ,k  ]  # 東側
    ms = 1.0-m[i  ,j-1,k  ]  # 南側
    mn = 1.0-m[i  ,j+1,k  ]  # 北側
    mb = m[i  ,j  ,k-1]      # 下側（注：1-maskではない）
    mt = m[i  ,j  ,k+1]      # 上側

    # 界面熱伝導係数（λf関数使用）
    axm = λf(λ[i-1,j,k], λ0, m[i-1,j,k], m0) * dx2 + mw*dx1*HT[1]
    axp = λf(λ[i+1,j,k], λ0, m[i+1,j,k], m0) * dx2 + me*dx1*HT[2]
    # ... (他の方向も同様)

    # 対角項（中心セルの係数）
    dd = (1.0-m0) + (axp + axm + ayp + aym + azp + azm)*m0

    # 7点ステンシル
    ss = ( axp * p[i+1,j  ,k  ] + axm * p[i-1,j  ,k  ]
         + ayp * p[i  ,j+1,k  ] + aym * p[i  ,j-1,k  ]
         + azp * p[i  ,j  ,k+1] + azm * p[i  ,j  ,k-1] )

    # 結果（マスクで境界を除外）
    ap[i,j,k] = (ss - dd*p[i,j,k]) * m0
end
```

**重要なポイント**:
1. **ループ範囲**: `i in 2:SZ[1]-1`（ガイドセルを除外）
2. **マスク値の反転**: `mw = 1.0-m[i-1,j,k]`（境界セルで1、内点で0）
3. **境界除外**: 最後に`* m0`を掛けて、境界セル（m0=0）の計算結果をゼロにする

### 1.5 境界条件別の処理

#### 熱流束境界（IHCPで使用）

**Heat3dsでの処理**:
1. **ガイドセル設定**:
   ```julia
   mask[境界] = 0.0
   λ[境界] = 0.0
   ```

2. **CalcRK!関数でのRHS項への追加**（heat3d_NonUniform.jl: 484-486行）:
   ```julia
   bb = b[i,j,k]+( (mw*HF[1] - me*HF[2])*dx1
                  +(ms*HF[3] - mn*HF[4])*dy1
                  +((1.0-mb)*HF[5] - (1.0-m0)*HF[6])/ΔZ[k] )
   ```
   - `HF[1]`, `HF[2]`, ...: 各面の熱流束値（W/m²）
   - `mw`, `me`, ...: 境界フラグ（1-mask）
   - 境界でのみ熱流束項が追加される

**IHCPでの現在の処理**（DHCPSolver.jl: 250-260行）:
```julia
# 表面（k=nk）での熱流束境界条件
if k_idx == nk
  # 表面からの熱流束入力
  b_val += q_surface[i, j] * dx * dy
  # 上方向の熱伝導を除去（表面で断熱）
  a_p_total += a_t_val
  a_t_val = 0.0
end
```
→ **if文で分岐処理**

## 2. IHCPの現在のデータ構造

### 2.1 配列サイズとインデックス範囲

**配列サイズ**: `[ni, nj, nk]`（ガイドセルなし）

| 領域 | インデックス範囲 | 意味 |
|------|----------------|------|
| **計算内点** | `[1:ni, 1:nj, 1:nk]` | 全ての点が物理領域 |
| **境界** | `i=1`, `i=ni`, etc. | 境界は内点の一部 |

### 2.2 境界条件の処理

**build_dhcp_system!関数**（DHCPSolver.jl: 101-270行）:
```julia
for k_idx in 1:nk, j in 1:nj, i in 1:ni
  # 6方向の境界チェック（if文で分岐）
  if j == 1
    a_w_val = 0.0  # 西側境界
  else
    # 調和平均
    k_w = 2.0 * k_p * k[i, j-1, k_idx] / (k_p + k[i, j-1, k_idx])
    a_w_val = k_w * dx * dz_k / dy
  end

  # ... (他の方向も同様にif文で処理)

  # 表面熱流束境界（k=nk）
  if k_idx == nk
    b_val += q_surface[i, j] * dx * dy
    a_p_total += a_t_val
    a_t_val = 0.0
  end
end
```
→ **各境界で個別にif文チェック**（計算コスト）

## 3. 2つのアプローチの比較

| 項目 | Heat3ds（ガイドセル方式） | IHCP（if文方式） |
|------|------------------------|----------------|
| **配列サイズ** | [ni+2, nj+2, nk+2] | [ni, nj, nk] |
| **メモリ使用量** | 約1.37倍（(ni+2)³/(ni)³） | ベースライン |
| **境界条件処理** | マスク配列で統一的 | if文で個別処理 |
| **計算効率** | 分岐なし（SIMD化容易） | 分岐あり（SIMD化困難） |
| **コードの複雑性** | シンプル（境界特殊処理不要） | 複雑（各境界で個別処理） |
| **テストの互換性** | 要変更 | 既存テスト使用可能 |

## 4. 移植方針の選択肢

### 方法1: ガイドセル方式を完全採用

**実装**:
1. 全ての配列を[ni+2, nj+2, nk+2]に変更
2. マスク配列を導入
3. Heat3dsのCalcAX!関数をそのまま移植

**メリット**:
- マトリックスフリー実装がシンプル
- 境界条件処理が統一的（コードが読みやすい）
- if文分岐なし → SIMD最適化が容易
- 将来的にGPU並列化も容易

**デメリット**:
- データ構造の大幅な変更
- 既存テスト（505項目）の大幅な修正が必要
- Python参照データとの形状不一致 → 変換処理が必要
- メモリ使用量が約37%増加

**見積もり**:
- 実装期間: 6-8週間（データ構造変更 + テスト修正）
- リスク: 高（既存機能が壊れる可能性）

### 方法2: IHCPのデータ構造を維持（ハイブリッド方式）

**実装**:
1. 配列サイズは[ni, nj, nk]のまま
2. マトリックスフリーCalcAX!関数内でのみガイドセル的な処理
3. 境界条件は現在のbuild_dhcp_system!の係数を再利用

**アプローチ2a: 係数配列を保持**
```julia
# 事前計算（既存のbuild_dhcp_system!を活用）
a_w, a_e, a_s, a_n, a_b, a_t, a_p, b = build_dhcp_system!(...)

# マトリックスフリーCalcAX!（係数を使用）
function CalcAX_DHCP!(ap, p, a_w, a_e, a_s, a_n, a_b, a_t, a_p)
    @floop for k in 1:nk, j in 1:nj, i in 1:ni
        p_idx = dhcp_index(i, j, k, ni, nj)

        # 7点ステンシル（係数は事前計算済み）
        ss = ( a_w[p_idx] * p[i, j-1, k] + a_e[p_idx] * p[i, j+1, k]
             + a_s[p_idx] * p[i-1, j, k] + a_n[p_idx] * p[i+1, j, k]
             + a_b[p_idx] * p[i, j, k-1] + a_t[p_idx] * p[i, j, k+1] )

        ap[i, j, k] = a_p[p_idx] * p[i, j, k] - ss
    end
end
```

**メリット**:
- データ構造変更なし
- 既存テストがそのまま使える
- 段階的な移植が可能（リスク低）
- 疎行列組み立てコストは削減できる

**デメリット**:
- 係数配列（a_w, ..., a_p）を保持する必要がある（メモリ増加）
- 境界条件処理のif文が残る（build_dhcp_system!内）
- Heat3dsほどシンプルにならない

**見積もり**:
- 実装期間: 3-4週間
- リスク: 低（既存機能を保持）

**アプローチ2b: 係数を都度計算（if文あり）**
```julia
function CalcAX_DHCP!(ap, p, T_prev, q_surface, ...)
    @floop for k in 1:nk, j in 1:nj, i in 1:ni
        # 6方向の係数をその場で計算（if文あり）
        if j == 1
            a_w_val = 0.0
        else
            k_w = 2.0 * k_p * k[i, j-1, k_idx] / (k_p + k[i, j-1, k_idx])
            a_w_val = k_w * dx * dz_k / dy
        end
        # ... (他の方向も同様)

        # 7点ステンシル
        ss = ( a_w_val * p[i, j-1, k] + ... )
        ap[i, j, k] = a_p_total * p[i, j, k] - ss
    end
end
```

**メリット**:
- 係数配列不要（メモリ削減）
- データ構造変更なし

**デメリット**:
- if文分岐が残る（SIMD最適化の障害）
- Heat3dsの利点（統一的な境界条件処理）が得られない

**見積もり**:
- 実装期間: 2-3週間
- リスク: 低

### 方法3: 段階的移行（推奨）

**Phase 2.3a**: まず方法2aで実装（3-4週間）
- データ構造変更なし
- マトリックスフリーBiCGstabの効果を確認
- 既存テスト505項目で検証

**Phase 2.3b**: 性能測定と評価（1週間）
- 疎行列組み立てコスト削減の効果を測定
- ボトルネックを特定

**Phase 2.4**: 必要に応じて方法1に移行（6-8週間）
- 性能改善が不十分な場合
- ガイドセル方式に完全移行
- より大きな性能向上を目指す

## 5. メモリ使用量の詳細比較

### 現在のIHCP（疎行列方式）

**問題サイズ**: ni=40, nj=50, nk=10, N=20,000

| 項目 | サイズ | 備考 |
|------|-------|------|
| 疎行列A（CSC形式） | 2.24 MB | 140,000非ゼロ要素×16B |
| RHSベクトルb | 0.16 MB | 20,000×8B |
| 解ベクトルx | 0.16 MB | 20,000×8B |
| **合計** | **2.56 MB** | |

### 方法2a: ハイブリッド方式（係数保持）

| 項目 | サイズ | 備考 |
|------|-------|------|
| 係数配列（a_w,...,a_p） | 1.12 MB | 7×20,000×8B |
| RHSベクトルb | 0.16 MB | 20,000×8B |
| 解ベクトルx | 0.16 MB | 20,000×8B |
| ワークベクトル（8個） | 1.28 MB | 8×20,000×8B（BiCGstab用） |
| **合計** | **2.72 MB** | 現在+6% |

**削減項目**: 疎行列A（2.24 MB削減）
**増加項目**: ワークベクトル（1.28 MB増加）
**正味削減**: 0.96 MB（38%削減）

### 方法1: ガイドセル方式

**問題サイズ**: ni+2=42, nj+2=52, nk+2=12, N=26,208

| 項目 | サイズ | 備考 |
|------|-------|------|
| 温度場T | 0.21 MB | 26,208×8B |
| マスク配列mask | 0.21 MB | 26,208×8B |
| 熱伝導率λ | 0.21 MB | 26,208×8B |
| RHSベクトルb | 0.21 MB | 26,208×8B |
| ワークベクトル（8個） | 1.68 MB | 8×26,208×8B |
| **合計** | **2.52 MB** | 現在-2% |

**メモリ削減**: 疎行列A不要（2.24 MB削減）
**メモリ増加**: ガイドセル分（約31%容量増）
**正味削減**: わずかな削減

## 6. 推奨方針

### 短期戦略（Phase 2.3a）: 方法2a採用

**理由**:
1. **リスク最小**: データ構造変更なし、既存テスト使用可能
2. **効果確実**: 疎行列組み立てコスト削減（12.4秒）
3. **実装期間短い**: 3-4週間
4. **段階的移行可能**: 後でガイドセル方式に移行可能

### 中長期戦略（Phase 2.4）: 方法1への移行検討

**移行条件**:
- 方法2aで性能改善が不十分（<15%）
- より大きな性能向上が必要（目標: 30-50%）
- GPU並列化を視野に入れる

**移行タイミング**:
- Phase 2.3aの性能測定後
- テスト整備が完了後

## 7. 次のステップ

### Phase 2.3a実装計画（3-4週間）

**Week 1**: CalcAX_DHCP!実装
- build_dhcp_system!の係数計算を再利用
- マトリックスフリー行列ベクトル積実装
- 単体テスト

**Week 2**: PBiCGSTAB_DHCP!実装
- BiCGstabアルゴリズム実装
- 対角Jacobi前処理
- Phase 2テストスイート（298項目）で検証

**Week 3**: Adjoint版実装
- CalcAX_Adjoint!とPBiCGSTAB_Adjoint!
- Phase 3テストスイート（13項目）で検証

**Week 4**: 統合とベンチマーク
- CGMとの統合
- Phase 4-6テスト（169項目）で検証
- 性能測定

---

**作成日**: 2025年10月3日
**Phase**: 2.3準備 - ガイドセルとマスク配列の詳細分析
**推奨**: 方法2a（ハイブリッド方式）で開始 → 必要に応じて方法1に移行
**ブランチ**: tuning2（分析作業中）
